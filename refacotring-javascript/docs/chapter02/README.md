# 리팩터링: 리팩터링 원칙

이번 장에서는 잠시 시야를 넓혀 리팩터링 전반에 적용되는 원칙 몇 가지를 이야기하는 시간을 갖자.

<br/>

## 2.1 리팩터링 정의

리팩터링이란 용어는 명사로도 사용할 수 있고 동사로도 사용하는 게 가능하다.

**리팩터링(명사): 소프트웨어의 겉보기 동작을 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 바꾸는 것**

**리팩터링(동사): 소프트웨어의 겉보기 동작을 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.**

리팩터링은 성능 최적화와 비슷하다.

둘 다 코드를 변경하지만 프로그램의 기능은 정상적으로 작동한다.

단지 목적만 다를 뿐이다.

리팩터링은 코드를 이해하고 수정하기 쉽게 바꾸는 것이라면

성능 최적화는 오로지 속도에만 신경 쓴다.

그래서 목표 성능에 반드시 도달해야 한다면 코드의 이해는 더 어려워질 수 있다.

<br/>

## 2.2 두개의 모자

나는 소프트웨어를 개발할 때 목적을 두 개로 나눈다. '기능 추가'와 '리팩터링'을 명확히 구별한다.

켄트 백은 이를 두 개의 모자에 비유했다.

기능을 추가할 때는 '기능 추가' 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 코드를 쓰는 것에만 집중한다.

진척도는 테스트를 통과하느냐를 확인하는 방법으로 측정한다.

리팩터링할 때는 '리팩터링 모자'를 쓴 다음 기능 추가는 절대 하지 않기로 다짐하고 오로지 코드 재구성에만 신경 쓴다.

이는 앞 과정에서 놓친 테스트 케이스를 발견하지 않는다면 절대 테스트도 추가하지 않는다.

부득이 인터페이스를 변경할 때만 기존 테스트를 수정한다.

인터페이스를 바꾸는 건 기능 추가의 종류 중 하나라고 생각한다.

소프트웨어를 개발하는 동안 나는 두 모자를 자주 바꿔 쓴다.

새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 수월하겠다는 생각이 드는데 그러면 잠시 '기능 추가 모자' 에서 '리팩터링 모자'로 바꿔쓴다.

그다음에 리팩터링이 다 끝나면 기존의 기능 추가 모자를 다시 쓴다.

정리하면 소프트웨어를 개발할 때 내가 어떤 모자를 쓰고 있는지 늘 점검하면서 개발하자.

<br/>

## 2.3 리팩터링하는 이유

오로지 코드를 이해하기 쉽고 수정하기 쉽도록 바꾸는 것이다.

<br/>

### 리팩터링하면 소프트웨어 설계가 좋아진다.

코드만 봐서는 설계를 파악하기 어려워지고 코드 구조가 무너지기 시작하면 악효과가 누적된다.

코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패한다. 즉, 확장을 할 수 없는 단계에 다다른다.

같은 일을 하더라도 설계가 나쁘면 코드가 길어진다.

사실상 같은 일을 하는 코드가 여러 곳에 나타나게 된다. **중복 코드가 낳는 문제는 수정하는 비용과 이해하는 비용이 많이 증가한다는 점이다.**

<br/>

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

코드는 컴퓨터만 읽는 게 아니다. 나와 같이 일하는 또는 개발자도 코드를 읽는다.

코드를 이해하기 쉽게 쓰지 않았더라면 이는 다른 개발자를 배려하지 못한 것이다.

잘 작동하지만, 이상적인 구조가 아닌 코드가 있다면 잠깐 시간을 내서 리팩터링하는 걸 추천한다.

코드의 목적이 더 잘 드러나게 의도가 더 잘 표현되게 개선하자.

리팩터링은 다른 사람들뿐 아니라 나 자신을 위해서라도 해야 한다.

내가 작성한 코드들을 다 외우지 않는다. 실제로 언제든지 잊어버릴 수 있다.

<br/>

### 리팩터링하면 버그를 쉽게 찾을 수 있다

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말과도 같다.

리팩터링하면 코드가 하는 일이 명확해지므로 이는 버그를 발견하는 데 도움을 준다.

이 사실은 켄트 백의 말을 떠올리게 해준다. **"난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."**

리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.

<br/>

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

지금까지 제시한 장점을 추상화하면 다음과 같다. 리팩터링하면 코드 개발 속도를 높일 수 있다.

얼핏 그 반대가 아닌가 생각할 수도 있다.

리팩터링이 내부 설계와 코드 퀄리티를 높일 수 있다는 점은 대부분 순응한다.

하지만 리팩터링하는 데 시간이 드니 전체 개발 속도가 떨어질까 봐 걱정할 수도 있다.

한 시스템을 오래 개발하는 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만, **현재는 새 기능을 하나 추가하는 데 훨씬 오래 걸린다는 말을 많이 한다.**

새로운 기능을 추가할수록 기존 코드 베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이다.

하지만 좋은 설계를 지닌 팀은 기존에 작성한 코드를 최대한 활용할 수 있어서 새 기능을 더 빨리 추가하는 게 가능해진다.

이렇게 차이 나는 원인은 소프트웨어의 내부 품질에 있다.

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 때 모듈화가 잘되어 있어서 코드의 작성 포인트를 쉽게 찾을 수 있다.

코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.

내부 품질이 뛰어난 코드 베이스는 새 기능 구축을 돕는다.

나는 이 효과를 설계 지구력 가설(Design Stamina Hypothesis)이라고, 부른다.

**내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 지속할 수 있다.**

<br/>

## 2.4 언제 리팩터링해야 할까?

<br/>

### 3의 법칙

> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면 (중복이 생겼다면) 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.
>
> 야구를 좋아하는 사람은 "스트라이크 세 번이면 리팩터링하라" 하고 기억해도 좋다.

<br/>

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드 베이스에 기능을 추가하기 직전이다.

구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

가령 내 요구사항을 모두 만족하지만, 리터럴 값 몇 개가 방해되는 함수가 있을 수 있다.

함수를 복제해서 해당 값만 수정해도 되지만, 그러면 중복 코드가 생긴다.

나중에 이 기능을 바꾼다면 수정 포인트가 여러 개가 되므로 리팩터링한다.

<br/>

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 코드를 파악해야 한다.

나는 코드를 파악할 때마다 그 코드의 의도가 명확하게 드러나도록 리팩터링할 여지가 없는지 찾아본다.

조건부 로직도 찾아보고, 함수의 이름이 올바른지도 찾아본다.

이쯤 되면 코드를 이해하게 되고 그것들을 후에 기억하기 쉽게 리팩터링해 주면 된다.

<br/>

### 쓰레기 줍기 리팩터링

코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 많다.

로직이 쓸데없이 복잡하거나 매개 변수화한 함수 하나면 될 일을 거의 똑같이 함수 여러 개로 작성해 놓았을 수 있다.

이때는 절충이 필요하다.

원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 쓰기는 싫을 것이다.

그렇다고 쓰레기가 나뒹굴게 방치해서 일을 방해하도록 내버려 두는 것도 좋지 않다.

**나라면 간단히 수정할 수 있는 것은 지금 하고 그렇지 못한 것은 메모해 두고 일을 끝내고 처리한다.**

이것이 이해를 위한 리팩터링의 변형된 부분인 쓰레기 줍기 리팩터링이다.

물론 수정하려면 몇 시간이나 걸리고 당장 더 급한 일이 있을 수 있다.

그렇더라고 캠핑 규칙을 따르자. **항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.**

<br/>

### 계획된 리팩터링과 수시로 하는 리팩터링

앞에서 본 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 한다.

나는 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고 기능을 추가하거나 버그를 잡을 때 리팩터링을 같이한다.

이는 프로그래밍 과정에 자연스럽게 리팩터링을 녹인 것이다.

리팩터링은 프로그래밍과 별개의 것이 아니다.

사람들은 리팩터링을 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해한다.

보기 싫은 코드를 보면 리팩터링 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

오랫동안 사람들은 소프트웨어 개발이 뭔가 '추가'하는 과정으로 여겼다.

기능을 추가하다 보면 대개 새로운 코드를 작성해 넣게 된다.

**하지만 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.**

그동안 리팩터링에 소홀했다면 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드 베이스를 개선할 필요가 있다.

리팩터링은 기능 추가와 밀접하게 연관되어 있기 때문에 굳이 나누는 것은 시간 낭비다.

<br/>

### 오래 걸리는 리팩터링

예컨대 라이브러리를 바꾸는 일이라면 기존 것과 새로운 것 모두 포용하는 추상 인터페이스를 만들고 

기존 코드가 추상 인터페이스를 호출하도록 하면 라이브러리를 훨씬 쉽게 고칠 수 있다. 

이 전략을 [**추상화로 갈아타기**](https://martinfowler.com/bliki/BranchByAbstraction.html)라고 한다.

<br/>

### 리팩터링하지 말아야 할 때

내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.

리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.

리팩터링은 직접 해보기 전에는 알기 어렵기 때문이다.

<br/>

## 2.5 리팩터링 시 고려할 문제

나는 누가 특정한 기술, 도구, 아키텍처 등을 내세울 때마다 항상 문제점을 찾는다. 

항상 화창한 날만 있는 것이 아니기에, 그래서 무언가를 언제 어디에 적용할지 판단하려면 **손익을 제대로 이해해야 한다.** (비난이 아닌 온전한 이해를 통한 대화를 해야 한다.)

<br/>

### 새 기능 개발 속도 저하

**리팩터링의 궁극적인 목표는 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.**

새 기능을 구현해 넣기 편해지겠다 싶은 리팩터링이라면 주저하지 말고 리팩터링부터 한다.

리팩터링의 본질을 잊지 말자. 리팩터링은 개발 기간을 단축하고자 하는 것이다.

리팩터링의 동력은 경제적인 효과를 늘 생각하자.

<br/>

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.

그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.

진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다. 

그 과정에서 (작고 멋진 이름의 함수처럼) 소프트웨어의 복잡에 지장을 주지 않는 메커니즘은 마은 껏 추가하지만,

소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음 껏 추가하지만, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다.

<br/>

## 2.7 리팩터링과 소프트웨어 개발 프로세스

자가 테스트 코드와 리팩터링을 묶어서 **테스트 주도 개발(TDD)**이라고 한다.

**자가 테스트 코드, 지속적 통합, 리팩터링**이라는 세 기법은 서로 강력한 상승효과를 발휘한다.

<br/>

## 2.8 리팩터링과 성능

리팩터링을 하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.

의도적으로 성능 최적하에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.

그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램밍을 튜닝한다.

성능 분석을 할 때 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다.


<br/>

## 마지막으로

리팩터링 연습에 주력한 책을 원한다면 윌리엄 웨이크(William C.Wake)가 쓴 '리팩터링 워크북'을 추천한다.

조슈아 케리에프스카가 쓴 '패턴을 활용한 리팩터링'을 추천한다.

스캇 엠블러(Scott Ambler)와 프라모드 사달게(Pramod Sadalage)의 '리팩터링 데이터베이스'와 

엘리엇 러스티 해롤드(Elliotte Rusty Harold) '리팩터링 HTML'이 있다.

마이클 페더스(Michael Feathers)의 '레거시 코드 활용 전략' 또한 추천한다.

웹사이트로는 'https://refactoring.com/'를 참고하기 바란다.
